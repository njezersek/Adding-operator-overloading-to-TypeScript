"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s)
                if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
        return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
            ar.push(r.value);
    }
    catch (error) {
        e = { error: error };
    }
    finally {
        try {
            if (r && !r.done && (m = i["return"]))
                m.call(i);
        }
        finally {
            if (e)
                throw e.error;
        }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar)
                    ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __values = (this && this.__values) || function (o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m)
        return m.call(o);
    if (o && typeof o.length === "number")
        return {
            next: function () {
                if (o && i >= o.length)
                    o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var tsp;
(function (tsp) {
    var activeProgramTransformers = new Set();
    var dirname = require("path").dirname;
    function getProjectDir(compilerOptions) {
        return compilerOptions.configFilePath && dirname(compilerOptions.configFilePath);
    }
    function getProjectConfig(compilerOptions, rootFileNames) {
        var configFilePath = compilerOptions.configFilePath;
        var projectDir = getProjectDir(compilerOptions);
        if (configFilePath === undefined) {
            var baseDir = (rootFileNames.length > 0) ? dirname(rootFileNames[0]) : projectDir !== null && projectDir !== void 0 ? projectDir : process.cwd();
            configFilePath = ts.findConfigFile(baseDir, ts.sys.fileExists);
            if (configFilePath) {
                var config = readConfig(configFilePath);
                compilerOptions = __assign(__assign({}, config.options), compilerOptions);
                projectDir = getProjectDir(compilerOptions);
            }
        }
        return ({ projectDir: projectDir, compilerOptions: compilerOptions });
    }
    function readConfig(configFileNamePath) {
        var projectDir = dirname(configFileNamePath);
        var result = ts.readConfigFile(configFileNamePath, ts.sys.readFile);
        if (result.error)
            throw new Error("Error in tsconfig.json: " + result.error.messageText);
        return ts.parseJsonConfigFileContent(result.config, ts.sys, projectDir, undefined, configFileNamePath);
    }
    function preparePluginsFromCompilerOptions(plugins) {
        if (!plugins)
            return [];
        if ((plugins.length === 1) && plugins[0].customTransformers) {
            var _a = plugins[0].customTransformers, _b = _a.before, before = _b === void 0 ? [] : _b, _c = _a.after, after = _c === void 0 ? [] : _c;
            return __spreadArray(__spreadArray([], __read(before.map(function (item) { return ({ transform: item }); })), false), __read(after.map(function (item) { return ({ transform: item, after: true }); })), false);
        }
        return plugins;
    }
    function createProgram(rootNamesOrOptions, options, host, oldProgram, configFileParsingDiagnostics) {
        var e_1, _a, e_2, _b;
        var _c;
        var rootNames;
        var createOpts = !Array.isArray(rootNamesOrOptions) ? rootNamesOrOptions : void 0;
        if (createOpts) {
            rootNames = createOpts.rootNames;
            options = createOpts.options;
            host = createOpts.host;
            oldProgram = createOpts.oldProgram;
            configFileParsingDiagnostics = createOpts.configFileParsingDiagnostics;
        }
        else {
            options = options;
            rootNames = rootNamesOrOptions;
        }
        var projectConfig = getProjectConfig(options, rootNames);
        if (tsp.isTSC) {
            options = projectConfig.compilerOptions;
            if (createOpts)
                createOpts.options = options;
        }
        var program = createOpts ?
            ts.originalCreateProgram(createOpts) :
            ts.originalCreateProgram(rootNames, options, host, oldProgram, configFileParsingDiagnostics);
        var plugins = preparePluginsFromCompilerOptions(options.plugins);
        var pluginCreator = new tsp.PluginCreator(plugins, (_c = projectConfig.projectDir) !== null && _c !== void 0 ? _c : process.cwd());
        var programTransformers = new Map(pluginCreator.getProgramTransformers());
        try {
            for (var _d = __values(pluginCreator.getProgramTransformers()), _e = _d.next(); !_e.done; _e = _d.next()) {
                var _f = __read(_e.value, 1), transformer = _f[0];
                if (activeProgramTransformers.has(transformer))
                    programTransformers.delete(transformer);
                else
                    activeProgramTransformers.add(transformer);
            }
        }
        catch (e_1_1) {
            e_1 = { error: e_1_1 };
        }
        finally {
            try {
                if (_e && !_e.done && (_a = _d.return))
                    _a.call(_d);
            }
            finally {
                if (e_1)
                    throw e_1.error;
            }
        }
        try {
            for (var programTransformers_1 = __values(programTransformers), programTransformers_1_1 = programTransformers_1.next(); !programTransformers_1_1.done; programTransformers_1_1 = programTransformers_1.next()) {
                var _g = __read(programTransformers_1_1.value, 2), programTransformer = _g[0], config = _g[1];
                var newProgram = programTransformer(program, host, config, { ts: ts });
                if (typeof (newProgram === null || newProgram === void 0 ? void 0 : newProgram["emit"]) === "function")
                    program = newProgram;
            }
        }
        catch (e_2_1) {
            e_2 = { error: e_2_1 };
        }
        finally {
            try {
                if (programTransformers_1_1 && !programTransformers_1_1.done && (_b = programTransformers_1.return))
                    _b.call(programTransformers_1);
            }
            finally {
                if (e_2)
                    throw e_2.error;
            }
        }
        programTransformers.forEach(function (c, transformer) { return activeProgramTransformers.delete(transformer); });
        if (!program.originalEmit) {
            program.originalEmit = program.emit;
            program.emit = newEmit;
        }
        function newEmit(targetSourceFile, writeFile, cancellationToken, emitOnlyDtsFiles, customTransformers) {
            var e_3, _a;
            var additionalArgs = [];
            for (var _i = 5; _i < arguments.length; _i++) {
                additionalArgs[_i - 5] = arguments[_i];
            }
            var transformers = pluginCreator.createTransformers({ program: program }, customTransformers);
            var result = program.originalEmit.apply(program, __spreadArray([targetSourceFile, writeFile, cancellationToken, emitOnlyDtsFiles, transformers], __read(additionalArgs), false));
            try {
                for (var _b = __values(tsp.diagnosticMap.get(program) || []), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var diagnostic = _c.value;
                    if (!result.diagnostics.includes(diagnostic))
                        result.diagnostics.push(diagnostic);
                }
            }
            catch (e_3_1) {
                e_3 = { error: e_3_1 };
            }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return))
                        _a.call(_b);
                }
                finally {
                    if (e_3)
                        throw e_3.error;
                }
            }
            return result;
        }
        return program;
    }
    tsp.createProgram = createProgram;
})(tsp || (tsp = {}));
var tsp;
(function (tsp) {
    Object.defineProperties(ts, {
        isTSC: { get: function () { return tsp.isTSC; }, enumerable: true },
        tspVersion: { get: function () { return tsp.tspVersion; }, enumerable: true },
        PluginCreator: { get: function () { return tsp.PluginCreator; }, enumerable: true },
        originalCreateProgram: { value: ts.createProgram, enumerable: true },
        createProgram: { value: tsp.createProgram },
        diagnosticMap: { get: function () { return tsp.diagnosticMap; }, enumerable: true }
    });
})(tsp || (tsp = {}));
var tsp;
(function (tsp) {
    var path = require("path");
    var fs = require("fs");
    var tsNodeIncluded = false;
    var requireStack = [];
    var PluginCreator = (function () {
        function PluginCreator(configs, resolveBaseDir) {
            var e_4, _a;
            if (resolveBaseDir === void 0) {
                resolveBaseDir = process.cwd();
            }
            this.configs = configs;
            this.resolveBaseDir = resolveBaseDir;
            PluginCreator.validateConfigs(configs);
            try {
                for (var configs_1 = __values(configs), configs_1_1 = configs_1.next(); !configs_1_1.done; configs_1_1 = configs_1.next()) {
                    var config = configs_1_1.value;
                    if (config["beforeEmit"])
                        config.transformProgram = true;
                }
            }
            catch (e_4_1) {
                e_4 = { error: e_4_1 };
            }
            finally {
                try {
                    if (configs_1_1 && !configs_1_1.done && (_a = configs_1.return))
                        _a.call(configs_1);
                }
                finally {
                    if (e_4)
                        throw e_4.error;
                }
            }
        }
        PluginCreator.prototype.mergeTransformers = function (into, source) {
            var _a, _b, _c;
            var slice = function (input) { return (Array.isArray(input) ? input.slice() : [input]); };
            if (source.before)
                (_a = into.before).push.apply(_a, __spreadArray([], __read(slice(source.before)), false));
            if (source.after)
                (_b = into.after).push.apply(_b, __spreadArray([], __read(slice(source.after)), false));
            if (source.afterDeclarations)
                (_c = into.afterDeclarations).push.apply(_c, __spreadArray([], __read(slice(source.afterDeclarations)), false));
            return this;
        };
        PluginCreator.prototype.createTransformers = function (params, customTransformers) {
            var e_5, _a;
            var transformers = { before: [], after: [], afterDeclarations: [] };
            var _b = __read(("ls" in params) ? [params.ls, params.ls.getProgram()] : [void 0, params.program], 2), ls = _b[0], program = _b[1];
            try {
                for (var _c = __values(this.configs), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var config = _d.value;
                    if (!config.transform || config.transformProgram)
                        continue;
                    var factory = this.resolveFactory(config);
                    if (factory === undefined)
                        continue;
                    this.mergeTransformers(transformers, PluginCreator.createTransformerFromPattern({ factory: factory, config: config, program: program, ls: ls }));
                }
            }
            catch (e_5_1) {
                e_5 = { error: e_5_1 };
            }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return))
                        _a.call(_c);
                }
                finally {
                    if (e_5)
                        throw e_5.error;
                }
            }
            if (customTransformers)
                this.mergeTransformers(transformers, customTransformers);
            return transformers;
        };
        PluginCreator.prototype.getProgramTransformers = function () {
            var e_6, _a;
            var res = [];
            try {
                for (var _b = __values(this.configs), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var config = _c.value;
                    if (!config.transform || !config.transformProgram)
                        continue;
                    var factory = this.resolveFactory(config);
                    if (factory === undefined)
                        continue;
                    res.push([factory, config]);
                }
            }
            catch (e_6_1) {
                e_6 = { error: e_6_1 };
            }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return))
                        _a.call(_b);
                }
                finally {
                    if (e_6)
                        throw e_6.error;
                }
            }
            return res;
        };
        PluginCreator.prototype.resolveFactory = function (config) {
            var _a;
            var tsConfig = config.tsConfig && path.resolve(this.resolveBaseDir, config.tsConfig);
            var transform = config.transform;
            var importKey = config.import || "default";
            var tsConfigCleanup;
            if (transform.match(/\.ts$/)) {
                if (tsNodeIncluded && (tsConfig !== this.currentProject))
                    tsNodeIncluded = false;
                this.currentProject = tsConfig;
                if (!tsNodeIncluded) {
                    try {
                        require("ts-node").register(__assign(__assign({ transpileOnly: true }, (tsConfig ? { project: tsConfig } : { skipProject: true })), { compilerOptions: {
                                target: "ES2018",
                                jsx: "react",
                                esModuleInterop: true,
                                module: "commonjs",
                            } }));
                        tsNodeIncluded = true;
                    }
                    catch (e) {
                        if (e.code === "MODULE_NOT_FOUND")
                            throw new Error("Cannot use a typescript-based transformer without ts-node installed. " +
                                "Either add ts-node as a (dev)-dependency or install globally.");
                        else
                            throw e;
                    }
                }
                var tsConfigData = tsConfig && ts.readConfigFile(tsConfig, ts.sys.readFile).config;
                if ((_a = tsConfigData === null || tsConfigData === void 0 ? void 0 : tsConfigData.compilerOptions) === null || _a === void 0 ? void 0 : _a.paths) {
                    try {
                        var tsConfigPaths = require("tsconfig-paths");
                        var absoluteBaseUrl = tsConfigPaths.loadConfig(tsConfig).absoluteBaseUrl;
                        tsConfigCleanup = tsConfigPaths.register({
                            baseUrl: absoluteBaseUrl,
                            paths: tsConfigData.compilerOptions.paths
                        });
                    }
                    catch (e) {
                        if (e.code === "MODULE_NOT_FOUND")
                            console.warn("Paths specified in transformer tsconfig.json, but they may not be able to be resolved. " +
                                "If not, try adding 'tsconfig-paths' as a dev dependency");
                        else
                            throw e;
                    }
                }
            }
            var modulePath = require.resolve(transform, { paths: [this.resolveBaseDir] });
            if (requireStack.indexOf(modulePath) > -1)
                return;
            requireStack.push(modulePath);
            var commonjsModule = require(modulePath);
            requireStack.pop();
            tsConfigCleanup === null || tsConfigCleanup === void 0 ? void 0 : tsConfigCleanup();
            var factoryModule = (typeof commonjsModule === "function") ? { default: commonjsModule } : commonjsModule;
            var factory = factoryModule[importKey];
            if (!factory)
                throw new Error("tsconfig.json > plugins: \"" + transform + "\" does not have an export \"" + importKey + "\": " +
                    require("util").inspect(factoryModule));
            if (typeof factory !== "function") {
                throw new Error("tsconfig.json > plugins: \"" + transform + "\" export \"" + importKey + "\" is not a plugin: " +
                    require("util").inspect(factory));
            }
            return factory;
        };
        PluginCreator.validateConfigs = function (configs) {
            var e_7, _a;
            try {
                for (var configs_2 = __values(configs), configs_2_1 = configs_2.next(); !configs_2_1.done; configs_2_1 = configs_2.next()) {
                    var config = configs_2_1.value;
                    if (!config.name && !config.transform)
                        throw new Error("tsconfig.json plugins error: transform must be present");
                }
            }
            catch (e_7_1) {
                e_7 = { error: e_7_1 };
            }
            finally {
                try {
                    if (configs_2_1 && !configs_2_1.done && (_a = configs_2.return))
                        _a.call(configs_2);
                }
                finally {
                    if (e_7)
                        throw e_7.error;
                }
            }
        };
        PluginCreator.createTransformerFromPattern = function (_a) {
            var factory = _a.factory, config = _a.config, program = _a.program, ls = _a.ls;
            var transform = config.transform, after = config.after, afterDeclarations = config.afterDeclarations, name = config.name, type = config.type, transformProgram = config.transformProgram, cleanConfig = __rest(config, ["transform", "after", "afterDeclarations", "name", "type", "transformProgram"]);
            if (!transform)
                throw new Error("Not a valid config entry: \"transform\" key not found");
            var ret;
            switch (config.type) {
                case "ls":
                    if (!ls)
                        throw new Error("Plugin " + transform + " needs a LanguageService");
                    ret = factory(ls, cleanConfig);
                    break;
                case "config":
                    ret = factory(cleanConfig);
                    break;
                case "compilerOptions":
                    ret = factory(program.getCompilerOptions(), cleanConfig);
                    break;
                case "checker":
                    ret = factory(program.getTypeChecker(), cleanConfig);
                    break;
                case undefined:
                case "program":
                    var _b = tsp.diagnosticExtrasFactory(program), addDiagnostic = _b.addDiagnostic, removeDiagnostic = _b.removeDiagnostic, diagnostics = _b.diagnostics;
                    ret = factory(program, cleanConfig, {
                        ts: ts,
                        addDiagnostic: addDiagnostic,
                        removeDiagnostic: removeDiagnostic,
                        diagnostics: diagnostics,
                        library: tsp.getCurrentLibrary()
                    });
                    break;
                case "raw":
                    ret = function (ctx) { return factory(ctx, program, cleanConfig); };
                    break;
                default:
                    throw new Error("Invalid plugin type found in tsconfig.json: '" + config.type + "'");
            }
            if (typeof ret === "function")
                return after ? ({ after: ret }) :
                    afterDeclarations ? ({ afterDeclarations: ret }) :
                        { before: ret };
            return ret;
        };
        return PluginCreator;
    }());
    tsp.PluginCreator = PluginCreator;
})(tsp || (tsp = {}));
var tsp;
(function (tsp) {
    tsp.diagnosticMap = new WeakMap();
    function diagnosticExtrasFactory(program) {
        var diagnostics = tsp.diagnosticMap.get(program) || tsp.diagnosticMap.set(program, []).get(program);
        var addDiagnostic = function (diag) { return diagnostics.push(diag); };
        var removeDiagnostic = function (index) { diagnostics.splice(index, 1); };
        return { addDiagnostic: addDiagnostic, removeDiagnostic: removeDiagnostic, diagnostics: diagnostics };
    }
    tsp.diagnosticExtrasFactory = diagnosticExtrasFactory;
    tsp.getCurrentLibrary = function () { return require("path").basename(__filename, require("path").extname(__filename)); };
})(tsp || (tsp = {}));
