"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.unpatch = exports.patch = exports.check = exports.uninstall = exports.install = exports.setOptions = exports.parseFiles = exports.defaultInstallLibraries = exports.RESOURCES_PATH = exports.BACKUP_DIRNAME = exports.SRC_FILES = void 0;
var path = __importStar(require("path"));
var fs = __importStar(require("fs"));
var glob_1 = __importDefault(require("glob"));
var chalk_1 = __importDefault(require("chalk"));
var shell = __importStar(require("shelljs"));
var patcher_1 = require("./patcher");
var file_utils_1 = require("./file-utils");
var system_1 = require("./system");
/* ********************************************************************************************************************
 * Config
 * ********************************************************************************************************************/
// region Config
shell.config.silent = true;
exports.SRC_FILES = ['tsc.js', 'tsserverlibrary.js', 'typescript.js', 'typescriptServices.js', 'tsserver.js'];
exports.BACKUP_DIRNAME = 'lib-backup';
exports.RESOURCES_PATH = path.join(system_1.appRoot, system_1.tspPackageJSON.directories.resources);
exports.defaultInstallLibraries = ['tsc.js', 'typescript.js'];
// endregion
/* ********************************************************************************************************************
 * Helpers
 * ********************************************************************************************************************/
// region Helpers
/**
 * Parse file, array of files, or glob of files and get TSModule info for each
 */
function parseFiles(fileOrFilesOrGlob, libDir, includeSrc) {
    if (includeSrc === void 0) { includeSrc = false; }
    var files = Array.isArray(fileOrFilesOrGlob) ? fileOrFilesOrGlob :
        fs.existsSync((0, file_utils_1.getModuleAbsolutePath)(fileOrFilesOrGlob, libDir)) ? [fileOrFilesOrGlob] :
            glob_1.default.sync(fileOrFilesOrGlob);
    var ret = files.map(function (f) { return (0, file_utils_1.getTSModule)((0, file_utils_1.getModuleAbsolutePath)(f, libDir), includeSrc); });
    return (0, system_1.defineProperties)(ret, {
        patched: { get: function () { return ret.filter(function (f) { return f.patchVersion; }); } },
        unPatchable: { get: function () { return ret.filter(function (f) { return !f.canPatch; }); } },
        canUpdateOrPatch: { get: function () { return ret.filter(function (f) { return f.canPatch && f.outOfDate; }); } },
        patchable: { get: function () { return ret.filter(function (f) { return f.canPatch; }); } },
    });
}
exports.parseFiles = parseFiles;
/**
 * Create backup of TS Module file
 */
function backup(tsModule, tsPackage) {
    var backupDir = path.join(tsPackage.packageDir, exports.BACKUP_DIRNAME);
    if (tsModule.patchVersion)
        throw new Error("Cannot backup an already patched module. You may need to reinstall typescript.");
    try {
        (0, file_utils_1.mkdirIfNotExist)(backupDir);
    }
    catch (e) {
        throw new system_1.BackupError(tsModule.filename, "Couldn't create backup directory. " + e.message);
    }
    if (shell.cp(tsModule.file, backupDir) && shell.error())
        throw new system_1.BackupError(tsModule.filename, shell.error());
    if (tsModule.filename === 'typescript.js')
        if (shell.cp(path.join(tsModule.dir, 'typescript.d.ts'), backupDir) && shell.error())
            throw new system_1.BackupError('typescript.d.ts', shell.error());
}
/**
 * Restore module from backup
 */
function restore(currentModule, tsPackage, noDelete) {
    var copyOrMove = function (fileName, dest) {
        return shell[noDelete ? 'cp' : 'mv'](fileName, dest);
    };
    var backupDir = path.join(tsPackage.packageDir, exports.BACKUP_DIRNAME);
    var _a = (0, file_utils_1.getTSModule)(path.join(backupDir, currentModule.filename)), file = _a.file, filename = _a.filename, canPatch = _a.canPatch, patchVersion = _a.patchVersion, dir = _a.dir;
    /* Verify backup file */
    if (!canPatch)
        throw new system_1.RestoreError(filename, "Backup file is not a valid typescript module!");
    if (patchVersion)
        throw new system_1.RestoreError(filename, "Backup file is not an un-patched ts module");
    /* Restore files */
    if (copyOrMove(file, tsPackage.libDir) && shell.error())
        throw new system_1.RestoreError(filename, "Couldn't restore file - " + shell.error());
    if (filename === 'typescript.js')
        if (copyOrMove(path.join(dir, 'typescript.d.ts'), tsPackage.libDir) && shell.error())
            throw new system_1.RestoreError(filename, "Couldn't restore file - " + shell.error());
    /* Verify restored file */
    var restoredModule = (0, file_utils_1.getTSModule)(currentModule.file);
    if (!restoredModule.canPatch)
        throw new system_1.RestoreError(filename, "Restored file is not a valid typescript module! You will need to reinstall typescript.");
    if (restoredModule.patchVersion)
        throw new system_1.RestoreError(filename, "Restored file still has patch! You will need to reinstall typescript.");
    // Remove backup dir if empty
    if ((fs.readdirSync(backupDir).length < 1) && shell.rm('-rf', backupDir) && shell.error())
        (0, system_1.Log)(['!', "Error deleting backup directory" + chalk_1.default.grey("[" + backupDir + "]")], system_1.Log.verbose);
}
// endregion
/* ********************************************************************************************************************
 * Actions
 * ********************************************************************************************************************/
// region Actions
/**
 * Set app options (superimposes opts onto defaultOptions)
 */
var setOptions = function (opts) { return (0, system_1.resetOptions)(opts); };
exports.setOptions = setOptions;
/**
 * Patch TypeScript modules
 */
function install(opts) {
    var ret = patch(exports.defaultInstallLibraries, opts);
    if (ret)
        (0, system_1.Log)(['+', chalk_1.default.green("ts-patch installed!")]);
    return ret;
}
exports.install = install;
/**
 * Remove patches from TypeScript modules
 */
function uninstall(opts) {
    var ret = unpatch(exports.defaultInstallLibraries, opts);
    if (ret)
        (0, system_1.Log)(['-', chalk_1.default.green("ts-patch removed!")]);
    return ret;
}
exports.uninstall = uninstall;
/**
 * Check if files can be patched
 */
function check(fileOrFilesOrGlob, opts) {
    if (fileOrFilesOrGlob === void 0) { fileOrFilesOrGlob = exports.SRC_FILES; }
    var dir = (0, system_1.parseOptions)(opts).dir;
    var _a = (0, file_utils_1.getTSPackage)(dir), libDir = _a.libDir, packageDir = _a.packageDir, version = _a.version;
    (0, system_1.Log)("Checking TypeScript " + chalk_1.default.blueBright("v" + version) + " installation in " + chalk_1.default.blueBright(packageDir) + "\r\n");
    var modules = parseFiles(fileOrFilesOrGlob, libDir);
    for (var _i = 0, modules_1 = modules; _i < modules_1.length; _i++) {
        var module_1 = modules_1[_i];
        var filename = module_1.filename, patchVersion = module_1.patchVersion, canPatch = module_1.canPatch, outOfDate = module_1.outOfDate;
        if (patchVersion)
            (0, system_1.Log)(['+',
                chalk_1.default.blueBright(filename) + " is patched with ts-patch version " +
                    (chalk_1.default[outOfDate ? 'redBright' : 'blueBright'](patchVersion) + " " + (outOfDate ? '(out of date)' : ''))
            ]);
        else if (canPatch)
            (0, system_1.Log)(['-', chalk_1.default.blueBright(filename) + " is not patched."]);
        else
            (0, system_1.Log)(['-', chalk_1.default.red(chalk_1.default.redBright(filename) + " is not patched and cannot be patched!")]);
        (0, system_1.Log)('', system_1.Log.verbose);
    }
    return modules;
}
exports.check = check;
/**
 * Patch a TypeScript module
 */
function patch(fileOrFilesOrGlob, opts) {
    if (!fileOrFilesOrGlob)
        throw new system_1.PatchError("Must provide a file path, array of files, or glob.");
    var dir = (0, system_1.parseOptions)(opts).dir;
    var tsPackage = (0, file_utils_1.getTSPackage)(dir);
    var modules = parseFiles(fileOrFilesOrGlob, tsPackage.libDir, true);
    if (!modules.canUpdateOrPatch.length) {
        (0, system_1.Log)(['!',
            "File" + (modules.length - 1 ? 's' : '') + " already patched with the latest version. For details, run: " +
                chalk_1.default.bgBlackBright('ts-patch check')
        ]);
        return false;
    }
    /* Patch files */
    for (var _i = 0, _a = modules.canUpdateOrPatch; _i < _a.length; _i++) {
        var m = _a[_i];
        var file = m.file, filename = m.filename;
        (0, system_1.Log)(['~', "Patching " + chalk_1.default.blueBright(filename) + " in " + chalk_1.default.blueBright(path.dirname(file))], system_1.Log.verbose);
        // If already patched, load backup module source. Otherwise, backup un-patched
        if (m.patchVersion)
            m.moduleSrc =
                (0, file_utils_1.getTSModule)(path.join(tsPackage.packageDir, exports.BACKUP_DIRNAME, m.filename), /* includeSrc */ true).moduleSrc;
        else
            backup(m, tsPackage);
        (0, patcher_1.patchTSModule)(m, tsPackage);
        tsPackage.config.modules[filename] = fs.statSync(file).mtimeMs;
        (0, system_1.Log)(['+', chalk_1.default.green("Successfully patched " + chalk_1.default.bold.yellow(filename) + ".\r\n")], system_1.Log.verbose);
    }
    tsPackage.config.save();
    if (modules.unPatchable.length > 1) {
        (0, system_1.Log)(['!',
            "Some files can't be patched! Try updating to a newer version of ts-patch. The following files are unable to be " +
                ("patched. [" + modules.unPatchable.map(function (f) { return f.filename; }).join(', ') + "]")
        ]);
        return false;
    }
    return true;
}
exports.patch = patch;
function unpatch(fileOrFilesOrGlob, opts) {
    if (!fileOrFilesOrGlob)
        throw new system_1.PatchError("Must provide a file path, array of files, or glob.");
    var _a = (0, system_1.parseOptions)(opts), dir = _a.dir, verbose = _a.verbose, instanceIsCLI = _a.instanceIsCLI;
    var tsPackage = (0, file_utils_1.getTSPackage)(dir);
    var modules = parseFiles(fileOrFilesOrGlob, tsPackage.libDir, true);
    if (modules.patched.length < 1) {
        (0, system_1.Log)(['!', "File" + (modules.length - 1 ? 's' : '') + " not patched. For details, run: " + chalk_1.default.bgBlackBright('ts-patch check')]);
        return false;
    }
    /* Restore files */
    var errors = {};
    for (var _i = 0, _b = modules.patched; _i < _b.length; _i++) {
        var tsModule = _b[_i];
        var file = tsModule.file, filename = tsModule.filename;
        (0, system_1.Log)(['~', "Restoring " + chalk_1.default.blueBright(filename) + " in " + chalk_1.default.blueBright(path.dirname(file))], system_1.Log.verbose);
        try {
            restore(tsModule, tsPackage);
            delete tsPackage.config.modules[filename];
            (0, system_1.Log)(['+', chalk_1.default.green("Successfully restored " + chalk_1.default.bold.yellow(filename) + ".\r\n")], system_1.Log.verbose);
        }
        catch (e) {
            errors[filename] = e;
        }
    }
    /* Save config, or handle if no patched files left */
    if (Object.keys(tsPackage.config.modules).length > 0)
        tsPackage.config.save();
    else {
        // Remove ts-patch.json file
        shell.rm('-rf', tsPackage.config.file);
    }
    /* Handle errors */
    if (Object.keys(errors).length > 0) {
        Object.values(errors).forEach(function (e) {
            if (!instanceIsCLI)
                console.warn(e);
            else
                (0, system_1.Log)(['!', e.message], system_1.Log.verbose);
        });
        (0, system_1.Log)('');
        throw new system_1.RestoreError("[" + Object.keys(errors).join(', ') + "]", 'Try reinstalling typescript.' +
            (!verbose ? ' (Or, run uninstall again with --verbose for specific error detail)' : ''));
    }
    return true;
}
exports.unpatch = unpatch;
// endregion
//# sourceMappingURL=actions.js.map